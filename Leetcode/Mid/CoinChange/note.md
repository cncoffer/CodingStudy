# 8-16

# 算法一

首先是考虑计算出能凑出总金额的所有可能组合, 然后找出用到硬币最少的那种.

那么如何计算出所有可能的组合呢, 可以使用回溯法来递归计算.

# 算法二

这题就是告诉我要用动态规划, 我也没想到要怎么用啊...
那先改进算法一, 很明显, 在大面额的币优先使用的规则下, 找到的第一个结果就一定是最小的结果.
那就先把币按照面额从大到小排序.

好吧, 上面的规则并不成立, 对于下面例子
[186,419,83,408]
6249

使用贪婪法得到的结果是26, 但正确结果是20.

# 算法三

设dp[i] 为兑换目标i最少的硬币数
则有下面转移方程
dp[i] = min(dp[i – coins[j]] + 1,dp[i]) // i > 0
        0 // i == 0

转移方程的意思就是在目标i中把当前硬币先选上, 然后查找是否有最小选项, 如果有最小选项那么就有dp[i] = di[i-coins[j]] + 1

