# 8-16

找出最长上升子序列, 元素不一定要连续的.
如[1,4,2]的最长上升子序列为[1,2]

# 算法一

假设a[j]为第j个元素的上升子序列长度, 则
a[j] = num[0]~num[j-1]中小于num[j]的元素的最大上升子序列长度 + 1
        1 // 前面没有元素小于num[j]

这样对于每一个元素都要和他前面的比较, 所以时间复杂度为o(n^2)

# 算法二

要将时间复杂度降低到o(nlogn).
那肯定是要改进转移公式, 因为需要遍历一遍整个数组的o(n)肯定是不可避免的.

想不到, 看看别人的答案.
算法二准确的来说并没有使用动态规划了.
算法是这样的
- 首先声明一个结果队列ret[], 并将第一个元素放入第一位.
- 接着对num[]进行遍历, 从1到n-1, 每一个首先都和ret[]的最后一个元素比较, 如果num[i]大, 就将其放入ret的末尾, 否则就使用二分法查找num应该放置的位置并替换进去.
- 最后ret[]的长度即为结果长度.

这里就有个问题了, 为什么可以替换进去, 不用考虑元素出现的顺序吗?
顺序没有问题, 因为如果后面的序列比前面小而且长度更长的话会完全覆盖掉的.
例如下面的例子, 在遍历到1时, 将ret中的10覆盖, 遍历到2时, 将ret中的11覆盖, 在遍历到3时, 把3插入ret的末尾. 所以最后ret的长度为3.
[10, 11, 1, 2, 3]

