# 8-15

矩阵有如下特性
- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

在矩阵中快速查找元素是否存在.

# 算法一

暴力算法, o(n^2)

# 算法二

按照矩阵的特性, 可以有如下结论
如果某个点a[i][j] < target, 则a[m][n] < target (if m<=i &&n <= j)
也就是说可以把左上角或右下角扣掉.
那这个特性能带来什么好处吗

另外还有个结论, 对角线上的点是递增的.

然后先来看一个例子
    [1,   4,  7, 11, 15],
    [2,   5,  8, 12, 19],
    [3,   6,  9, 16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]

当要查找target=7的时候, 首先在对角线上找, 如果没找到就返回小于他的那个元素的坐标, (i=j=1), 那么查找范围就缩小到了下面两个矩形
[3,  6] 和 [7, 11, 15]
[10,13]    [8, 12, 19]
[18,21]    [9, 16, 22]

然后对这两个矩形递归调用上面的算法.

这样每次查找的时间为o(n), 需要做logn次, 所以总的时间复杂度为o(nlogn).

先实现上面这个, 在对角线上进行二分查找容易出错.

其实在对角线上可以使用二分查找, 那么每次查找的时间缩减为o(logn)
所以这样总的时间复杂度为o(n).

		{ 1, 4, 7,11,15},
		{ 2, 5, 8,12,19},
		{ 3, 6, 9,16,22},
		{10,13,14,17,25} 

算法一中对于left和right写反了, 不过我也懒得改了...

看看人家更好的算法是怎么做的吧.

# 算法二

这个真的是没想到, 人家的代码就短短20行就行了.
算法是这样的
从左下角num[m][0]开始, 如果num[m][0] > target, 那么target一定不在当前行(因为num[m][0]右侧的都比他大), 接下来比较的数字往上移动一格.
如果num[m][0] < target, 那么target一定不在当前列, 接下来比较的数字往右移动一格.
就这样一格一格的移动, 直到找到数字或者移动出边界.

如此时间复杂度为o(n).