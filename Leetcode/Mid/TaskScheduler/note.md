# 8-18

给定一组任务, 后面的数字表示两个相同任务之间的cpu时间间隔.
tasks = ["A","A","A","B","B","B"], n = 2

# 算法一

首先将tasks转存到map中, 然后需要任务的时候都优先从map中数量最多的任务取, 如果取不到就拿第二多的. 如果一个都拿不到就等待. 这个第一多第二多可以用大根堆来实现, 插入和删除的时间都为o(logn)

STL自带堆的实现, 还是比较方便的.
    priority_queue<int> xxx 大根堆
    priority_queue<int, vector<int>, greater<int>> xxxx 小根堆

也就是说每一次循环都取一个任务来做, 取任务的规则如上所述, 最后取完任务时循环的次数即为结果.

每一次循环取一次任务, 这样时间复杂度为o(nlogn).

确实可行, 但是速度比较慢.

# 算法二

使用数学方法.
既然答案没有要求我们输出任务序列, 只要时间, 那么就可以用数学方法来计算.
time = max(总任务数, (最多任务的次数 - 1) * (等待时间 + 1) +  与最多任务次数相等的任务数)

如果中间不需要间隔, 那就是总任务数. 如果中间需要间隔, 那就是第二种情况~

理论上是ok的, 测试也确实ok. 而且比算法一还好懂.