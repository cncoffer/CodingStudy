# 8-11

之前做过一题是这道题的延伸, 区别是这题不能多次买卖, 所以要找出能使利润最大的拿一手买和卖.

# 算法一

那还是分解问题, 
    f(n) = f(n-1) + prices[n] - prices[n-1]; // 如果fn(n)小于0, 就让他等于0.
    f(0) = 0
    f(1) = prices[n] - prices[n-1];

然后计算完整个数组的同时, 记录下最大值即可.

那其实这么看来并不需要保存完整的数组, 而是保存前一个结果就行了.
这样也可以把空间复杂度控制在o(1).

# 算法二

看了别人的代码才知道的.
首先用一个数保存最低买入价, 然后不停的比较当前价格和最低买入价的差值, 如果差值大于max就记录下来.
最后返回结果.

这样就不需要额外的数组来存储动态规划的结果了.