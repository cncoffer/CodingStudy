# 8-9

因为链表是单向的, 所以用两个指针一个往前一个往后是行不通滴.
要求时间复杂度为o(n), 空间复杂度为o(1)

三个算法感觉都ok呀, 前两个实现一下吧. 最后一个可以利用上一题的代码.

看了比较快的两个方法, 一个是用vector, 一个使用stack, 都没做到o(1)呢.
我第三个算法挺好的, 满足了时间复杂度和空间复杂度两个要求.

# 算法一

首先想到的是将结果转存到一个数组中.
然后再从两端比较是否是回文.
这样做的话时间复杂度ok, 空间复杂度为o(n).

讲道理, vector的push_back是相对比较慢的, 也许先预估一个较大的空间会更快一点.

# 算法二

想到了之前在成对数的集合中找单身狗的题.
那题使用异或, 可以将两两相等的数异或掉.
但这题不仅是数相等, 还要保证位置也是对称的.
如何能够将位置和数值互不影响的异或到一个二进制存储中呢?

想到一个方法, 如果链表长度不超过int的最大值的话, 可以使用long long类型来存储结果. 因为我们的链表中的数值是用int存储的, 而long long类型的长度刚好是int型的两倍. 可以将位置信息存储在高位, 将value存储在地低位.

并且在遍历的同时, 要将中位数和size记录下来, 
如果size为奇数, cmp=中位数, 或者size为偶数, cmp=0, 则表示为回文.

这一方法并不可行, 因为不同的几个数异或也可能凑成结果为0的.
比如
    1 = 0b0001
    3 = 0b0011
    0 = 0b0000
    2 = 0b0010

# 算法三

想到一种算法, 不过这种算法会破坏原来的链表.
就是先遍历一遍链表, 找到中间位置, 然后把前半个链表翻转, 这时候就可以和后半个链表一一比较了.

