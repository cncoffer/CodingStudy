# 8-6

这题肯定做过很多次了.
再来做一次, 看看会有什么新的收获呢.

# 算法一

首先对数组进行排序, o(nlogn)
然后将两个index设置为首尾, 比较`num[front]+num[behind]`和target, 如果前者大, 就将behind向前移动, 如果后者大, 就将front向后移动.
直到找到结果或者front和begind相交. o(n)

最终时间复杂度为o(nlogn), 空间复杂度为o(1)

# 算法二

将数组存入hash表, 然后遍历数组对于num[index], 查找hash表中是否存在target-num[index], 如果存在就返回结果.

这样时间复杂度为o(n), 空间复杂度为o(n).

# 算法三

这是算法二的改进, 看了别人的代码, 发现第一遍对数组的遍历都不需要了呢, 确实厉害.

在遍历数组的同时, 搜索hash表, 如果找到就返回结果, 如果没找到就把当前数字放入map中.