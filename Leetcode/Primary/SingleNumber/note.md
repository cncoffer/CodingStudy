# 8-5

题目要求时间复杂度为o(n), 并且不能使用额外空间来实现.

那首先不考虑所有限制, 想到了两个方法
1. 排序后遍历一遍, 找到第一个不相同的数据.
2. 遍历数组统计每个元素出现的次数, 可以用散列来记录结果.

前一个时间复杂度不满足, 后一个空间复杂度不满足.

那就要利用另外一个给出的条件的, 其余每个元素均出现两次, 只有某一个元素出现了一次.

看美国leetcode的提示, 这个题可以先不考虑额外空间的限制, 那就先用hash来做吧.

看了示例答案, 原来是这样, 使用按位异或操作将数值都保存在一个result上, 在对数组进行遍历后就能保证成对的数值互相抵消.

