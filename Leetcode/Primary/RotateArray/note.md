# 8-5

限制条件, 使用空间复杂度为o(1)的算法.

# 算法一

首先实现一个向右移动一格的算法.
然后对传入的k多次调用.
时间复杂度为o(k*n)

# 算法二

计算每个元素最终应该放到的位置, 直接把他们放到最终的位置上.
但是这里有个问题, 放过去的时候要将被覆盖的元素拷出来, 如果是放到临时变量中, 这样空间复杂度就是为o(k).
如果是再放到下一个目标位置, 那么如何记录哪些元素被移动过呢?

不用记录, 如果数组大小能被k整除说明这样的操作要做k次.
如果不能被k整除, 就说明要做`k%(n%k)==0?k/(n%k):1`次.

懒得实现了, 网上搜能够搜到更好的办法.

# 算法三

翻转数组法.
像翻转字符串那样, 先把前n-k个数字翻转, 然后把后k个数字翻转, 最后把整个数组翻转. 时间复杂度为o(n).

# 算法四

使用STL的erase和push_back方法.
我tm的, 这么简单的方法我怎么没有想到呢...

# 算法五

抽空 调试一下来了解原理吧.
    class Solution {
    public:
        void rotate(vector<int>& nums, int k) {
            if (nums.empty()) return;
            int n = nums.size(), start = 0;   
            while (n && (k %= n)) {
                for (int i = 0; i < k; ++i) {
                    swap(nums[i + start], nums[n - k + i + start]);
                }
                n -= k;
                start += k;
            }
        }
    };