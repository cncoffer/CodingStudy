# 8-7

在字符串a中查找字符串b第一次出现的位置.

ps. 当字符串b为空时, 返回0比较合理, 因为C语言的 strstr() 以及 Java的 indexOf(), 以及ruby的index都是返回0.

# 算法一

首先想到的是暴力匹配, o(n*m), 略过.

# 算法二

接着是想到之前看到过的sunny算法(是不是叫这个名字呀).
1. 将字符串b和a的头对齐
2. 比较b的末尾和a的对应位置的字符是否相等. 如果相等跳到4, 否则进入3.
3. 在b中从后往前找那个a中的字符, 找到后和刚刚的位置对齐. 回到2.
4. 继续往前一个个字符比较, 如果有不相等的, 就跳到3. 如果到第一个字符都匹配上了, 就返回结果.

这样b字符的比较基本上是单向移动的, 所以时间复杂度为o(m+n).

但总感觉哪里不对劲, 先实现试试吧.

# 算法三

上面这个算法错了, 而且应该叫sunday算法呢.
另外还有KMP算法.

这两个算法是比较普遍的了, 必须好好研究一下.

## sunday算法描述

sunday算法从前往后匹配字符串, 在匹配失败时, 关注主串中参加匹配的最末位字符的下一个字符. 即
- 如果该字符没有在模式串中出现则直接跳过, 即移动位数=模式串长度+1
- 否则, 移动位数 = 模式串长度 - 该字符最右出现的位置下标 = 模式串中该字符最右出现的位置到尾部的距离+1

sunday算法并不像KMP那样保证最坏情况也是o(n), 不过其实现比较简单, 而且对于匹配短字符串优势比较大.

# KMP算法

这应该是一个经典算法了, 翻了两本算法书都提到了这个算法.

kmp算法的核心就是预处理.
预处理时间为o(m), 匹配时间为o(n).

# 字符串匹配算法

对于字符串匹配算法, 一般来说都分为预处理和匹配两个步骤.
