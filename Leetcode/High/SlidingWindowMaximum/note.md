# 8-19

滑动窗口每次滑动一格, 返回每个滑动窗口中的最大值.

# 算法一

首先想到的是暴力算法, 每个滑动窗口都遍历.
时间复杂度为o(n*k)

# 算法二

接着想到了建立一个最大值堆, 每当窗口向右移动, 就删除左侧出去的元素, 并加入右侧进入的元素.
这样时间复杂度为o(nlogn)

我想错了, STL的大根堆并不提供删除特定元素的接口, 他只能删除top元素.
那就只能用vector存储了, 但是这样vector中的数组肯定是需要排序的, 这样插入和删除的时间复杂度为o(k), 所以总的时间复杂度也就和暴力算法一样了...

看了算法三, 发现还是可以用大根堆的, 在放入元素的时候将下标也放进去, 这样不删除元素了, 而是在弹出top()的时候, 先判断一下是否在当前窗口中, 如果不在就删除掉.
这样总的时间复杂度大约为o(nlogk), 估计比算法三稍稍慢一些.

# 算法三

还是算法二的思想, 不过维护元素的最大值使用了双端队列.
算法是这样的
- 用双向队列维护一个最大值队列, 将最大值的下标保存进来, 队头是最大元素的下标.
- 然后每次入队时, 都要检测当前元素是否大于队尾元素, 如果队尾元素大, 则保留(这是有可能在之后成为最大值的), 如果队尾元素小, 则删除并将当前元素放入队尾.
- 然后判断队头是否在当前窗口中, 不在的话需要删掉判断下一个.

这样的话感觉时间复杂度会略微大于o(n)啊, 虽然说不上是会大多少.

