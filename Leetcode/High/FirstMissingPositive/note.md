# 8-19

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。
要求是时间复杂度为o(n), 空间复杂度为o(1)

# 算法一

首先将数组排序, 然后遍历一遍即可.
时间复杂度为o(nlogn)
空间复杂度为o(1)

# 算法二

使用hash表计数, 然后遍历一遍hash表找出没有出现的数.
时间复杂度为o(n)
空间复杂度为o(n)

# 算法三

两个条件都要符合有点难呀. 
看了答案的算法, 其实也比较简单的.
思想是这样的
- 从头到尾遍历数组, 如果当前元素为1, 就交换到a[0], 如果当前元素为3, 就交换到a[2].

这样遍历完数组之后, 数组中的整数就都被放到了指定位置, 相当于一种有条件的排序.
然后只要检查指定位置是否有所需元素存在即可.
比如检查1是否在a[0], 2是否在a[1], 返回第一个不满足条件的元素下标.