# 7-23

这本书只规划了5小时来阅读, 包含复习前面的, 所以只能粗粗的浏览一遍了.
还行, 勉强做到了, 虽然new和delete那一章看的有点粗了.

# 条款26 尽可能延后变量定义式的出现时间

在变量真正被用到的时候再定义, 这样能最大限度的保证这样变量不会没有被用到, 从而避免了承担额外的构造析构等的开销.
而且不只应该延后变量的定义, 甚至应该尝试延后这份定义直到能够给他初值实参位置. 如果这样, 不仅能够避免构造非必要对象, 也可以避免无意义的default构造.
更深一层说, 以"具明显意义之初值"将变量初始化, 还可以附带说明变量的目的.

这么一说延迟定义的出现时间好处多多, 我的代码中也应该这么做.
回想一下vsp的初始化函数, 有非常多的定义在开头定义, 这样就很不靠谱, 而且用到的地方在几百行以后, 我找初始值和定义位置都很麻烦.

对于循环, 定义有两种方式, A定义于循环外, B定义域循环内.
A: 1个构造+1个析构+n个赋值操作 + 其他操作.
B: n个构造+n个析构 + 其他操作.

比较一下就可以知道, 如果赋值开销低于构造和析构, 就应该用A, 否则应该用B.
不过对于不知道的情况, 应该使用B, 因为B的作用域比A小, 引发问题的可能性也小.

# 条款27 尽量少做转型动作

如果要做, 也尽量使用新式转型.

旧式转型: (Type)expression, Type(expression).
新式转型: const_cast, dynamic_cast, reinterpret_cast, static_cast.
四个新式转型各有不同的目的
const_cast:         用来将对象的常量性移除(cast away the constness).
dynamic_cast:       执行"安全向下转型", 用来决定某对象是否归属继承体系中的某个类型, 可能会耗费较大运行成本. 尽量不要用.
reinterpret_cast:   执行低级转型, 例如将一个`pointer to int`转型为`int`,
static_cast:        用来强迫隐式转换, 如将`non-const`转换为`const`, 将int转为double等等.

许多程序员相信, 转型其实什么也没做, 只是告诉编译器把某种类型视为另一种类型.
这是错误的! 噫, 我原先也是这么错误的理解的...

其实编译器是会编译出运行期执行的代码来做转型操作的.
比如对于对象实例(派生类), 可能拥有一个以上的地址(如以base指向他时的地址和以childclass指向他时的地址), 多重继承时几乎就是确定的. 然后在转型的时候编译器就会做地址的转换.

在类中想要调用父类的函数, 应当直接用限定名称来指定, 而不是将this指针转型. 代码如下
    class MyClass : public BaseClass {
    public:
        virtual void onResize() {
            BaseClass::onResize();
            ...
        }
    }

使用dynamic_cast可能会带来比较大的开销, 特别是多重继承, 深度继承, 会需要比较多的class名称比较.
而之所以使用dynamic_cast, 通常是因为你想在一个你认定为是MyClass的对象身上执行MyClass class操作函数, 但你手上却只有一个指向BaseClass的指针.
有两个方法可以避免使用dynamic_cast:
1. 使用容器并在其中存储直接指向MyClass对象的指针. 缺点是没法包容其他类型.
2. 在基类中将要用的函数实现虚函数并且为什么都不做, 然后在使用的时候直接对指向BaseClass的指针调用函数.

最后, 宁可使用新式转型, 不要使用旧式转型. 前者容易识别, 而且分类比较明确, 使用范围的收窄能够带来更好的效果.

# 30 透彻了解inline的里里外外

inline的好处我知道, 但其实他也有坏处.
当inline较大, 并且过度使用时, 会导致程序体积增加, inline造成的代码膨胀亦会导致额外的换页行为, 降低指令告诉缓存装置的集中率, 以及伴随而来是效率损失.

class定义式内的函数定义(成员函数或者友元函数)是隐喻的inline申请, 比如下面这样的.
    class Person {
    public:
        int age() const {return m_theAge;} // 一个隐喻的inline申请.
    private:
        int m_theAge;
    }

template和inline, 虽然两者大多在头文件中实现定义, 但两者没有必然联系, 如果你想要template成为inline, 需要显式的指定.

virtual会使inline失效, 毕竟这两者是冲突的, virtual隐含着到运行期才确定调用哪个函数, 而inline是在编译器就替换的.

inline函数在使用上要保持谨慎, 特别是提供给客户时.
因为如果客户将inline函数本体编译进气程序中, 一旦想要修改inline函数时, 用到它的代码全部需要重新编译, 这带来的开销可能非常大.

# 条款31 将文件间的编译依存关系降至最低

将文件间的编译依存关系降至最低的本质: 让头文件尽可能自我满足, 如果做不到, 则让他与其他文件内的声明式(而非定义式)相依. 
下面有两条具体做法
- 如果使用object references或object pointers可以完成任务, 就不要使用objects. 因为前两者只需要类型的声明, 后者需要完整的定义(至少要用来计算大小).
- 如果能够, 尽量以class声明式替换class定义式. 当你声明一个函数而他用到某个class时, 你并不需要该class的定义.
- 使用抽象基类(接口类)指针替换实现类, 这样也能做到将依赖分离.
- 为声明式和定义式提供不同的头文件. 这一点让我想到了template中结合包含模式和手动实例化模式的例子. 真正需要时才包含定义式头文件, 不需要定义时可以只包含声明头文件.

本章所说C++的interface classes比java和.NET的interfaces更为强大, 因为他不禁止实现成员变量和成员函数.
这么一想确实啊, 虽然C++没有interface关键字, 但是能够做到.NET那样的interfaces, 而且可以更加灵活. 可以在interface class中实现静态工厂函数, 用于动态分配对象.

不过上面这些做法, 也是有副作用的, 会带来更多的对象, 更高的空间和时间开销.

需要自己去权衡, 究竟是想要封装和去耦合带来的好处, 还是性能上的好处, 当然啦对于各个局部模块可以有不同的考量.