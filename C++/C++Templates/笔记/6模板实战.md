# 6.1 包含模型 #

如果将template 函数/类的声明放在.h中, 定义放在.cpp中, 那么在link时会报错.
原因是这样的: 当编译器看到template的调用时, 可能还没有看到其基于某一个类型实例化的定义, 这是他假设在别处提供了这个定义, 并产生一个指向改定义的引用(让链接器利用该引用来解决这一问题). 而另一方面, 当编译器处理template的调用时, 他并没有指出: 编译器必须基于特定实参对所包含的模板定义进行实例化. 所以链接器肯定找不到这一实例化的定义.

而如果将template的声明和定义都放在.h中, 然后用到的地方包含这一.h文件, 就不会报错.

但是这样也带来了问题, 大大增加了编译复杂程序所耗费的时间.

# 6.2 显式实例化 #

在代码中将template手工实例化, 就能确保link的时候不会报错.
在用到的地方包含模板的声明, 然后手工实例化的例子:
    // templatefile.h
    template <typename T>
    void fun(T const& n);

    // main.cpp, 实例化一个int类型的函数
    #include "templatetest.cpp"
    template void fun<int>(int const&);

需要注意, 每个程序中, 相同的实例化体只能有一个, 也就是说上面的fun()函数, 我们只能手工实例化一次int类型.
如果在多处实例化int类型, 会导致链接错误.

到此, 我们发现显式实例化有一个致命缺点, 在大型工程中手工实例化需要人为的跟踪, 保证只能实例化一次.
不过好处也有, 对比包含模型, 可以减少开销, 并且只在需要的地方实例化.

结合包含模型和显式实例化的做法:
仍然将声明和定义放在两个问题, 然后声明的文件命名为stack.h, 定义的文件命名为stackdef.h(并且它肯定包含stack.h), 
如果希望使用包含模型, 就在代码中include头文件`stackdef.h`, 如果希望使用显式实例化, 就包含头文件`stack.h`然后手工实例化.

# 6.3 分离模型 #

对template使用export关键字.
虽然这是C++的标准, 但其实几乎没有编译器支持. 略过即可.

# 6.4 模板和内联 #

对短小的模板函数应该使用内联.
其实对大多数短小函数都应该使用内联, 能够有效的提高效率. 虽然我觉得编译器有时候会自己干这事儿.

# 6.5 预编译 #

预编译其实就是将共同需要用到的头文件放到一个.h中, 然后在用到的时候包含他. 
比如mfc的公共头文件STDAFX.H, 这应该算是非常常用的预编译头文件了.

# 6.6.4 跟踪程序 #

把构造, 析构, =运算等都重新封装, 并用静态变量保存运行过程中的结果, 然后把封装好的跟踪类传进模板中查看实际运行的情况.
本节写的跟踪程序真不错, 有需要可以参考着做, 感觉在设计一个复杂模板的时候这东西会需要用上.

