# 2 函数模板 #

由于历史原因, typename的出现比class晚一些, 以前关键字class是引入类型参数的唯一方式, 现在也被保留了下来, 下面这两种写法是等价的.
    typename <class T>
    inline T const& max(T const& a, T const& b)
    {
        return a < b ? a : b;
    }
    
    typename <typename T>
    ...

通常而言, 模板在编译时都会根据实际情况生成不同的实体, 也就是说对于不同参数会编译出各种不同的实体.
这一过程叫做实例化, 不过说到实例和实例化总是会想起class, 本书中一般是指template.

模板在实例化时, 如果试图基于一个不支持模板内部操作的类型来实例化一个模板, 那么会导致一个编译期错误.
也就是说, 在编译时, 模板至少会被编译两次, 
1. 实例化之前, 先检查模板代码本身, 查看语法是否正确.
2. 实例化期间, 检查模板代码, 查看是否所有的调用都有效.

这就带来了一个问题, 当使用函数模板, 并引发实例化时, 编译器需要知道模板的代码. 这就和函数的编译与链接不同(函数只要有声明就能编译成功).
在第六章会详细讨论这一问题, 现在可以先简单的使用inline来做.

# 2.3 模板参数 #

书中介绍了一个对于给模板传递两个不同类型调用参数的方法.
    template <typename RT, typename T1, typename T2>
    inline RT max (T1 const& a, T2 const& b)
    {...}

    ::max<double>(4, 4.2);

T1和T2让编译器推导, 返回值强制指定.
但其实对于这个问题, C++11的新特性能够很好的解决了, 不知道本书是在什么时候写的呢.
现在可以这样写
    template <typename T1, typename T2>
    inline auto max (T1 const& a, T2 const& b) -> decltype(a + b)
    {
        return a < b ? a : b;
    }

# 2.4 模板重载 #

先去看附录B, 那里对非模板的重载有详细的描述.