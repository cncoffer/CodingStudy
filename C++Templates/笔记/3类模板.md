# 3.1 类模板stack的实现 #

书中用vector实现了stack, 但其实STL中的stack是用deque实现的.

deque和vector有下面这些对比
1. 两端都能快速插入删除. 这是相同点...
2. 元素的存取和迭代器动作比vector稍慢.
3. deque使用不止一块内存(vector必须使用连续内存), 所以deque的max_size()理论上更大.
4. 不支持对容量和内存重新分配时机的控制, 不过deque的内存重分配优于vector, 因为不用再重分配是赋值所有元素.
5. deque的内存大小是可自动缩减的, 不用的区块会被自动释放.
6. 不能将deque的地址传给传统的C API, 比如数组, 因为deque的内存不一定连续.

C++标准建议, 默认情况下使用vector, 对于大多数插入和删除操作发生在序列的头/尾时, 应该选用deque. 后面的注释里(P28)有说使用deque更好(但是看和本文内容矛盾的情况, 这应该是译者注).

看到这里, 已经发现了这本书的两个错误了, 虽然不影响对template的解读, 但还是让人感觉不可靠啊.
再回来看, 发现是我站在了现在的角度来看, 所以会觉得是错误, 其实作者后面有说deque的问题, 而且这本书可是在2002年写的啊, 当时C++标准可不一定有这建议呢.

在使用类模板时, 成员函数的实现需要使用这个类模板的完整类型限定符MyClass<T>::, 例子如下
    template <typename T>
    class MyClass
    {
    public:
        void MyClass<T>::print();
        ...
    };

    template <typename T>
    void MyClass<T>::print()
    {
        ...
    }

vector的pop_back()方法只是删除末尾的元素, 并没有返回元素; 之所以如此是充分考虑了异常安全性, 因为要实现"一个绝对异常安全并且返回被删除元素的pop()"是不可能的. 还有这种说法啊, 有空可以调查一下.

对于类模板, 成员函数只有在被使用的时候才会实例化, 这是非常重要的一点. 他带来两个好处
1. 节省时间和空间.
2. 只要模板内部外部不使用"未能提供某些操作的"成员函数, 就可以用"未能提供某些操作"的类型来实例化类模板. 比如对于`operator<`, 如果不调用他以及使用它的函数的话, 我们用pair<>来实例化模板也没有问题.

# 3.5 缺省模板实参 #

可以为模板参数定义缺省值, 并且缺省值能够引用之前的模板参数.
    template <typename T, typename CONT = vector<T>>
    class MyClass2
    {
    private:
        CONT elems;
    public:
        void print();
    };

    template <typename T, typename CONT>
    void MyClass2<T, CONT>::print()
    {
        ...
    }

