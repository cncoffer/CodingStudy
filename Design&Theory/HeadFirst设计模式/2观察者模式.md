### 观察者模式 ###

观察者模式定义了对象之间的一对多依赖, 这样一来, 当一个对象改变状态时, 他的所有依赖者都会受到通知并自动更新.

在我看来观察者模式就是交互的一种方式, 一对一或一对多的交互.
在主题中提供订阅和取消订阅的接口, 并实现通知的方法(在需要通知时, 通知所有已订阅的用户).
在观察者中实现update()接口, 然后注册到主题当中, 就完成了订阅. 这里应该就是回调函数.

这样的设计之下, 主题是真正拥有数据的人, 而观察者是主题的依赖者, 这样在数据变化时, 主题相当于起到了数据分发的作用, 比起让许多对象控制同一份数据要逻辑清晰, 而且干净.

这种设计可以被称作松耦合, 主题不需要知道观察者具体是什么类, 会做什么以及具体细节, 也不需要为了适应观察者而做兼容性修改, 因为他主需要观察者来注册, 然后调用观察者提供的update()接口即可.

这么一想, 这一模式原来我已经接触了好久了, 在stopmotion模块中的btnid就是一个很典型的观察者模式吧.


### 观察者模式的实现 ###

可以自己实现, 也可以用线程的库.
C#中可以利用.net中IObservable<out T>和IObserver<in T>实现观察者模式.

在观察者模式中, 会改变的是主题的状态, 以及观察者的数目和类型. 用这个模式, 你可以改变依赖于主题状态的对象, 缺不必改变主题.