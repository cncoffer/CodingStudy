### 鸭子模型 ###

第一个鸭子模型就难倒了我, 如果在父类中实现fly()和quack(), 那么所有子类都会继承过去, 包括不可能飞的橡皮鸭子.
而如果用接口, 只有继承了接口的子类才需要实现的话, 那么代码的重复和维护会是一个大问题.
那就多重继承, 首先给一个抽象类, 然后把需要共用的方法放到继承自抽象类的父类中, 要用到的继承这个父类, 不用到的就不继承.
不过继承不是好选择, 用下面的策略模式会更好.

书中还完玩了一个梗, 在软件开发上, 一直不变的真理就是--变化!

如果要解决上面的问题, 可以将fly()和quack()的实现委托给行为类, 其实这种做法就和函数指针一样啊...
不过因为用到了接口, 所以封装性和逻辑能够做的更好.

多用组合, 少用继承.
解决上面这一问题用的就是组合, 将fly()和quack()在外部实现, 然后挑所需要的实现来组合起来, 就想拼积木一样.

### 策略模式 ###

原来学习了这么多, 我已经学到了一个设计模式--策略模式了.
	策略模式定义了算法族, 分别封装起来, 让他们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户.

不过我自己感觉下来, 这个策略模式的限制也是有的, 主要是算法独立的出去, 因此如果需要传递内部参数比较多的时候, 使用起来应该会比较麻烦. 这估计就需要非常好的封装才能尽量避免麻烦了.

看到P25的设计谜题, 突然想到, 原来游戏里面替换装备, 替换技能等等都可以用这种模式来做呢.
比如我换了一把武器, 而对于人物来说我同样的攻击行为, 如果用了策略模式, 就可以仍旧是调用同一个接口, 但是其具体的实现我就不用管了. 不过我这直接调用内部成员的相应接口也一样嘛, 不过思想就是这样的, 替换.

### 总结 ###

阅读本书时, 要时刻思考: 模式如何依赖基础与原则.

通常的做法是将系统中会变化的部分抽出来封装.
