# 状态模式

在看了需求描述之后, 首先思考一下, 如何实现这个状态模式, 比如说一个有限状态机, 要定义各个状态, 状态的行为以及状态转移的方式.

首先想到的是写一个while函数, 包含一个switch-case语句.
每个case表示一个状态, case中的代码表示状态的行为, 并在执行完后转移状态. 而每一次循环就是一次状态转移.

接着想到, 如果使用这样的语句就不好封装, 因为每次新增加一个状态都要去改这个函数.
那把每个状态封装成一个类如何呢, 但封装成类的话成员变量又不是共享的了.
看看书上是怎样的吧. 看了书发现我想多了, 共享成员变量很简单, 在state初始化的时候把外层的封装类的this指针传进去, 然后在外层封装类中提供和设置各种属性/成员变量的接口即可. 不过如果要访问私有对象的话, 还是要通过设置友元, 这样会再一次破坏封装性.

# 简单的实现

首先是定义各种状态, 用成员变量state保存. 然后给每一个动作实现一个接口, 调用接口表示各种行为.
接口函数实现根据不同的state执行不同的语句, 就是所有状态都有一个对应的state.

可以预见的增加state会异常麻烦.
增加行为的代码倒是可控的, 每个state一种嘛.

# 状态模式的实现

首先定义一个公共的基类StateBase(可以是抽象类/interface), 确定所有状态要实现的行为.
然后给每个状态定义一个类xxxState, 将状态的行为封装在类中.

接着在外层的封装中实例化这些子类, 并且定义一个成员变量保存当前的state.
然后外层封装要提供各个state的getter, 让state能够在自己的函数中转移状态.

在本例中, 其实很多报错信息的代码都是可以重用的, 所以更好的做法我觉得是首先还是实现一个抽象类StateBase,
然后派生一个基础行为类, 比如DefaultState, 将公共的代码都实现.
然后在具体的state类中, 将要做的行为再覆盖掉.

# 状态模式的定义

状态模式允许对象在内部状态改变时改变它的行为, 对象看起来好像修改了它的类.

我感觉状态模式简直就是多态的最好诠释.

不过这里还是有一个点, 状态类的转移是在状态类中做的, 也就是说状态类之间是有依赖关系的.
虽然在外层封装类中提供了getter, 会起到一定的作用, 但还是没有完全解决问题.

本章看完了, 这本书真的厉害, 用生动的例子让一点点我思考, 和书本一起推演出状态模式应有的样子.