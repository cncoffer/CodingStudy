### 工厂模式 ###

这本书真的是很赞啊...

任何对象都可以做用户, 如果他们有需要不停变化的东西, 都可以提出来做成一个单独的对象, 然后作为客户来调用, 这样就可以保证不停变换的东西不会影响到对象的其他部分了.

这个工厂刚好我这两台看代码就有看到过呢.

使用工厂的时候, 我们能够把具体的类创建放到工厂中, 而在使用的时候, 只关注他们提供的接口, 而且封装的好的话, 真的完全可以忽略具体是哪个类在给我们提供接口.


### 定义 ###

工厂方法模式定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.

如同披萨店那样, 在工厂方法中实现了披萨的各种准备生产过程, 但是创建是一个抽象方法, 让子类去具体实现.
这样在编写时, 可以不用考虑到时候会使用哪个类, 然后在使用时想用什么就创建什么就好了.

另外前面提到的简单工厂, 是将对象的创建封装起来, 然后用类似传入字符串等方式返回对象, 不过我们也不需要知道具体创建了什么对象.


	依赖倒置原则: 要依赖抽象, 不要依赖具体类.
简单来说, 就是不要让高层组件依赖底层组件, 而且两者都应该依赖于抽象.

抽象工厂模式: 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要明确指定具体类.

用抽象工厂其实就是把这一部分内容解耦出来(客户的代码中只能看到对抽象工厂的使用), 然后让用户在实际使用的时候去决定实例化哪一个(运行时才知道具体是哪一个).

书上的那张工厂模式的类图画的是真不错.

工厂的主要作用是封装对象的创建, 无论是简单工厂还是工厂方法模式亦或是抽象工厂, 然后客户在使用时, 只需要对相应接口进行调用, 不用关注具体事例化和使用的是哪个对象.

